// Code generated by "cmap-gen -package maps -type Location"; DO NOT EDIT.

package maps

import "hash/fnv"
import "sync"

// LocationMap is sharded concurrent map which key type is string and
// value type is Location
type LocationMap struct {
	shards []*LocationShard
	n      uint32
}

// NewLocationMap creates new LocationMap with specified shards count
func NewLocationMap(nShards int) *LocationMap {
	shards := make([]*LocationShard, nShards)
	for i := 0; i < nShards; i++ {
		shards[i] = NewLocationShard()
	}
	return &LocationMap{shards: shards, n: uint32(nShards)}
}

func (c LocationMap) hash(s string) uint32 {
	h := fnv.New32a()
	_, err := h.Write([]byte(s))
	if err != nil {
		panic(err)
	}
	return h.Sum32() % c.n
}

// Get returns the value stored by specified key
func (c LocationMap) Get(key string) Location {
	return c.shards[c.hash(key)].Get(key)
}

// Set stores the specified value under the specified key
func (c LocationMap) Set(key string, value Location) {
	c.shards[c.hash(key)].Set(key, value)
}

// LocationShard is concurrent map which key type is string and
// value type is Location
type LocationShard struct {
	mu   sync.RWMutex
	data map[string]Location
}

// NewLocationShard creates new LocationShard
func NewLocationShard() *LocationShard {
	return &LocationShard{
		data: make(map[string]Location),
	}
}

// Get returns the value stored by specified key
func (c *LocationShard) Get(key string) Location {
	c.mu.RLock()
	defer c.mu.RUnlock()
	return c.data[key]
}

// Set stores the specified value under the specified key
func (c *LocationShard) Set(key string, value Location) {
	c.mu.Lock()
	defer c.mu.Unlock()
	c.data[key] = value
}
